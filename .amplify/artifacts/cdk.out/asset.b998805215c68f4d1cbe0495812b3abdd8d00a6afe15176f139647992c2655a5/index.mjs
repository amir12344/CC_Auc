/** * Reads SSM environment context from a known Amplify environment variable, * fetches values from SSM and places those values in the corresponding environment variables */export const internalAmplifyFunctionResolveSsmParams = async (client) => {    const envPathObject = JSON.parse(process.env.AMPLIFY_SSM_ENV_CONFIG ?? '{}');    const paths = Object.values(envPathObject).map((paths) => paths.path);    if (paths.length === 0) {        return;    }    let actualSsmClient;    if (client) {        actualSsmClient = client;    }    else {        const ssmSdk = await import('@aws-sdk/client-ssm');        actualSsmClient = new ssmSdk.SSM();    }    const chunkArray = (array, chunkSize) => {        const chunks = [];        for (let i = 0; i < array.length; i += chunkSize) {            chunks.push(array.slice(i, i + chunkSize));        }        return chunks;    };    const resolveSecrets = async (paths) => {        const response = (await Promise.all(chunkArray(paths, 10).map(async (chunkedPaths) => await actualSsmClient.getParameters({            Names: chunkedPaths,            WithDecryption: true,        })))).reduce((accumulator, res) => {            accumulator.Parameters?.push(...(res.Parameters ?? []));            accumulator.InvalidParameters?.push(...(res.InvalidParameters ?? []));            return accumulator;        }, {            Parameters: [],            InvalidParameters: [],        });        if (response.Parameters && response.Parameters.length > 0) {            for (const parameter of response.Parameters) {                if (parameter.Name) {                    const envKey = Object.keys(envPathObject).find((key) => envPathObject[key].sharedPath === parameter.Name ||                        envPathObject[key].path === parameter.Name);                    if (envKey) {                        process.env[envKey] = parameter.Value;                    }                }            }        }        return response;    };    const response = await resolveSecrets(paths);    const sharedPaths = (response?.InvalidParameters || [])        .map((invalidParam) => Object.values(envPathObject).find((paths) => paths.path === invalidParam)?.sharedPath)        .filter((sharedParam) => !!sharedParam);     if (sharedPaths.length > 0) {        await resolveSecrets(sharedPaths);    }};await internalAmplifyFunctionResolveSsmParams();const SSM_PARAMETER_REFRESH_MS = 1000 * 60;setInterval(async () => {    try {        await internalAmplifyFunctionResolveSsmParams();    }    catch (error) {        try {                        console.debug(error);                    }        catch {                    }    }}, SSM_PARAMETER_REFRESH_MS);export {};
import{createRequire as h}from"node:module";import w from"node:path";import S from"node:url";global.require=h(import.meta.url);global.__filename=S.fileURLToPath(import.meta.url);global.__dirname=w.dirname(__filename);var u=process.env;import*as p from"fs/promises";import*as d from"path";async function b(e){try{let t=d.resolve(e);await p.access(t);let r=await import(t);return console.log("Module loaded successfully"),r}catch(t){return console.error("Error loading module:",t),null}}var s=null,f=async()=>s||(s=await b("/opt/nodejs/module-loading-layer.js"),s);var E=new Set(["access_details"]),O=async(e,t)=>{console.log(`EVENT: ${JSON.stringify(e)}`);try{let r=JSON.parse(u.DB_CONNECTION_DETAILS),a=`postgresql://${r.username}:${r.password}@${r.hostname}:${r.port}/${r.databaseName}?schema=public`,l=(await f())?.prismaClient(a),{modelName:c,operation:i,query:n}=e.arguments;if(!c||!i||!n)throw new Error("modelName, operation, and query are required");let g=new Set(y(JSON.parse(n)).flatMap(o=>o.split(".")));if(i.toLowerCase().includes("find")&&Array.from(g).filter(o=>E.has(o)).length>0)throw console.error("Request blocked to restricted table"),new Error("Request blocked to restricted table");let m={};try{let o=l[c][i];m=await o({...JSON.parse(n)})}catch(o){throw console.error("Error occurred while running query. ",n,o),o}finally{await l.$disconnect()}return JSON.stringify(m)}catch(r){throw console.error("Error occurred while handling event"),console.error(r),r}};function y(e,t=""){let r=[];for(let a in e)typeof e[a]=="object"&&e[a]!==null?r=r.concat(y(e[a],t+a+".")):r.push(t+a);return r}export{O as handler};
//# sourceMappingURL=index.mjs.map
