{
  "version": 3,
  "sources": ["../../../../node_modules/@aws-amplify/backend-function/src/lambda-shims/cjs_shim.ts", "../../../generated/env/query-data.ts", "../../../../amplify/functions/commons/importLayer.ts", "../../../../amplify/functions/query-data/handler.ts"],
  "sourcesContent": ["import { createRequire } from 'node:module';\nimport path from 'node:path';\nimport url from 'node:url';\nglobal.require = createRequire(import.meta.url);\nglobal.__filename = url.fileURLToPath(import.meta.url);\nglobal.__dirname = path.dirname(__filename);\n", "// This file is auto-generated by Amplify. Edits will be overwritten.\nexport const env = process.env as any;", "import * as fs from \"fs/promises\";\r\nimport * as path from \"path\";\r\nimport { PrismaClient } from \"../lambda-layers/core-layer/nodejs/prisma/generated/client\";\r\n\r\n// Define a generic type or use any if the type is not known beforehand\r\nasync function dynamicImportIfExists<T>(filePath: string): Promise<T | null> {\r\n  try {\r\n    const fullPath = path.resolve(filePath);\r\n    await fs.access(fullPath);\r\n    const module = (await import(fullPath)) as T;\r\n    console.log(\"Module loaded successfully\");\r\n    return module;\r\n  } catch (error) {\r\n    console.error(\"Error loading module:\", error);\r\n    return null;\r\n  }\r\n}\r\n\r\nlet module: PackageLoaderLayer | null = null;\r\n\r\n// Define the interface for the myScript from the lambda layer\r\n// amplify/functions/layer/nodejs/myScript.ts file\r\nexport interface PackageLoaderLayer {\r\n  prismaClient(prismaDataSourceUrl: string): PrismaClient | null;\r\n}\r\n\r\nexport const importModuleFromLayer = async () => {\r\n  if (module) {\r\n    return module;\r\n  }\r\n\r\n  // this code is inside the lambda layer\r\n  module = await dynamicImportIfExists<PackageLoaderLayer>(\r\n    \"/opt/nodejs/module-loading-layer.js\"\r\n  );\r\n\r\n  return module;\r\n};\r\n", "import { env } from \"$amplify/env/query-data\";\r\nimport type { Schema } from \"../../data/resource\";\r\nimport { importModuleFromLayer } from \"../commons/importLayer\";\r\n\r\ntype DatabaseConnectionDetails = {\r\n  databaseName: string;\r\n  hostname: string;\r\n  port: number;\r\n  username: string;\r\n  password: string;\r\n};\r\n\r\nconst RESTRICTED_TABLES = new Set([\"access_details\"]);\r\n\r\nexport const handler: Schema[\"queryData\"][\"functionHandler\"] = async (\r\n  event,\r\n  context\r\n) => {\r\n  console.log(`EVENT: ${JSON.stringify(event)}`);\r\n  try {\r\n    const dbConnectionDetails: DatabaseConnectionDetails = JSON.parse(\r\n      env.DB_CONNECTION_DETAILS\r\n    );\r\n    const prismaDataSourceUrl = `postgresql://${dbConnectionDetails.username}:${dbConnectionDetails.password}@${dbConnectionDetails.hostname}:${dbConnectionDetails.port}/${dbConnectionDetails.databaseName}?schema=public`;\r\n\r\n    const prismaClient = (await importModuleFromLayer())?.prismaClient(\r\n      prismaDataSourceUrl\r\n    )!;\r\n\r\n    const { modelName, operation, query } = event.arguments;\r\n\r\n    if (!modelName || !operation || !query) {\r\n      throw new Error(\"modelName, operation, and query are required\");\r\n    }\r\n\r\n    // Block sensitive data requests\r\n    // Prism's omit api seems to be not working, so adding a crude way to block requests\r\n    const attributeKeys = new Set(\r\n      getAllKeys(JSON.parse(query)).flatMap((key) => key.split(\".\"))\r\n    );\r\n\r\n    if (\r\n      operation.toLowerCase().includes(\"find\") &&\r\n      Array.from(attributeKeys).filter((key) => RESTRICTED_TABLES.has(key))\r\n        .length > 0\r\n    ) {\r\n      console.error(\"Request blocked to restricted table\");\r\n      throw new Error(\"Request blocked to restricted table\");\r\n    }\r\n\r\n    let queryResult = {};\r\n\r\n    try {\r\n      // TODO: find proper types\r\n      // @ts-ignore\r\n      const queryFunction = prismaClient[modelName][operation];\r\n      queryResult = await queryFunction({ ...JSON.parse(query) });\r\n    } catch (error) {\r\n      console.error(\"Error occurred while running query. \", query, error);\r\n      throw error;\r\n    } finally {\r\n      await prismaClient.$disconnect();\r\n    }\r\n\r\n    return JSON.stringify(queryResult);\r\n  } catch (err) {\r\n    console.error(\"Error occurred while handling event\");\r\n    console.error(err);\r\n    throw err;\r\n  }\r\n};\r\n\r\nfunction getAllKeys(obj: any, prefix: string = \"\"): string[] {\r\n  let keys: string[] = [];\r\n\r\n  for (const key in obj) {\r\n    if (typeof obj[key] === \"object\" && obj[key] !== null) {\r\n      keys = keys.concat(getAllKeys(obj[key], prefix + key + \".\"));\r\n    } else {\r\n      keys.push(prefix + key);\r\n    }\r\n  }\r\n\r\n  return keys;\r\n}\r\n"],
  "mappings": ";AAAA,OAAS,iBAAAA,MAAqB,cAC9B,OAAOC,MAAU,YACjB,OAAOC,MAAS,WAChB,OAAO,QAAUF,EAAc,YAAY,GAAG,EAC9C,OAAO,WAAaE,EAAI,cAAc,YAAY,GAAG,EACrD,OAAO,UAAYD,EAAK,QAAQ,UAAU,ECJnC,IAAME,EAAM,QAAQ,ICD3B,UAAYC,MAAQ,cACpB,UAAYC,MAAU,OAItB,eAAeC,EAAyBC,EAAqC,CAC3E,GAAI,CACF,IAAMC,EAAgB,UAAQD,CAAQ,EACtC,MAAS,SAAOC,CAAQ,EACxB,IAAMC,EAAU,MAAM,OAAOD,GAC7B,eAAQ,IAAI,4BAA4B,EACjCC,CACT,OAASC,EAAO,CACd,eAAQ,MAAM,wBAAyBA,CAAK,EACrC,IACT,CACF,CAEA,IAAID,EAAoC,KAQ3BE,EAAwB,SAC/BF,IAKJA,EAAS,MAAMH,EACb,qCACF,EAEOG,GCxBT,IAAMG,EAAoB,IAAI,IAAI,CAAC,gBAAgB,CAAC,EAEvCC,EAAkD,MAC7DC,EACAC,IACG,CACH,QAAQ,IAAI,UAAU,KAAK,UAAUD,CAAK,CAAC,EAAE,EAC7C,GAAI,CACF,IAAME,EAAiD,KAAK,MAC1DC,EAAI,qBACN,EACMC,EAAsB,gBAAgBF,EAAoB,QAAQ,IAAIA,EAAoB,QAAQ,IAAIA,EAAoB,QAAQ,IAAIA,EAAoB,IAAI,IAAIA,EAAoB,YAAY,iBAElMG,GAAgB,MAAMC,EAAsB,IAAI,aACpDF,CACF,EAEM,CAAE,UAAAG,EAAW,UAAAC,EAAW,MAAAC,CAAM,EAAIT,EAAM,UAE9C,GAAI,CAACO,GAAa,CAACC,GAAa,CAACC,EAC/B,MAAM,IAAI,MAAM,8CAA8C,EAKhE,IAAMC,EAAgB,IAAI,IACxBC,EAAW,KAAK,MAAMF,CAAK,CAAC,EAAE,QAASG,GAAQA,EAAI,MAAM,GAAG,CAAC,CAC/D,EAEA,GACEJ,EAAU,YAAY,EAAE,SAAS,MAAM,GACvC,MAAM,KAAKE,CAAa,EAAE,OAAQE,GAAQd,EAAkB,IAAIc,CAAG,CAAC,EACjE,OAAS,EAEZ,cAAQ,MAAM,qCAAqC,EAC7C,IAAI,MAAM,qCAAqC,EAGvD,IAAIC,EAAc,CAAC,EAEnB,GAAI,CAGF,IAAMC,EAAgBT,EAAaE,CAAS,EAAEC,CAAS,EACvDK,EAAc,MAAMC,EAAc,CAAE,GAAG,KAAK,MAAML,CAAK,CAAE,CAAC,CAC5D,OAASM,EAAO,CACd,cAAQ,MAAM,uCAAwCN,EAAOM,CAAK,EAC5DA,CACR,QAAE,CACA,MAAMV,EAAa,YAAY,CACjC,CAEA,OAAO,KAAK,UAAUQ,CAAW,CACnC,OAASG,EAAK,CACZ,cAAQ,MAAM,qCAAqC,EACnD,QAAQ,MAAMA,CAAG,EACXA,CACR,CACF,EAEA,SAASL,EAAWM,EAAUC,EAAiB,GAAc,CAC3D,IAAIC,EAAiB,CAAC,EAEtB,QAAWP,KAAOK,EACZ,OAAOA,EAAIL,CAAG,GAAM,UAAYK,EAAIL,CAAG,IAAM,KAC/CO,EAAOA,EAAK,OAAOR,EAAWM,EAAIL,CAAG,EAAGM,EAASN,EAAM,GAAG,CAAC,EAE3DO,EAAK,KAAKD,EAASN,CAAG,EAI1B,OAAOO,CACT",
  "names": ["createRequire", "path", "url", "env", "fs", "path", "dynamicImportIfExists", "filePath", "fullPath", "module", "error", "importModuleFromLayer", "RESTRICTED_TABLES", "handler", "event", "context", "dbConnectionDetails", "env", "prismaDataSourceUrl", "prismaClient", "importModuleFromLayer", "modelName", "operation", "query", "attributeKeys", "getAllKeys", "key", "queryResult", "queryFunction", "error", "err", "obj", "prefix", "keys"]
}
